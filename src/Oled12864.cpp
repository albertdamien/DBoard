/*
  Copyright (c) 2018 Damien ALBERT <damien@rouge-orange.fr>

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
*/

#include <Oled12864.h>
#include "Wire.h"

#define STATE_START 0
#define STATE_OFF   1
#define STATE_ON    2

// 8x8 Font ASCII 32 - 127 Implemented
// Users can modify this to support more characters(glyphs)
// BasicFont is placed in code memory.
const unsigned char BasicFont[][8] PROGMEM=
{
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // ' '
  {0x00,0x00,0x5F,0x00,0x00,0x00,0x00,0x00}, // !
  {0x00,0x00,0x07,0x00,0x07,0x00,0x00,0x00}, // "
  {0x00,0x14,0x7F,0x14,0x7F,0x14,0x00,0x00}, // #
  {0x00,0x24,0x2A,0x7F,0x2A,0x12,0x00,0x00}, // $
  {0x00,0x23,0x13,0x08,0x64,0x62,0x00,0x00}, // %
  {0x00,0x36,0x49,0x55,0x22,0x50,0x00,0x00}, // &
  {0x00,0x00,0x05,0x03,0x00,0x00,0x00,0x00}, // '
  {0x00,0x1C,0x22,0x41,0x00,0x00,0x00,0x00}, // (
  {0x00,0x41,0x22,0x1C,0x00,0x00,0x00,0x00}, // )
  {0x00,0x08,0x2A,0x1C,0x2A,0x08,0x00,0x00}, // *
  {0x00,0x08,0x08,0x3E,0x08,0x08,0x00,0x00}, // +
  {0x00,0xA0,0x60,0x00,0x00,0x00,0x00,0x00}, // ,
  {0x00,0x08,0x08,0x08,0x08,0x08,0x00,0x00}, // -
  {0x00,0x60,0x60,0x00,0x00,0x00,0x00,0x00}, // .
  {0x00,0x20,0x10,0x08,0x04,0x02,0x00,0x00}, // /
  {0x00,0x3E,0x51,0x49,0x45,0x3E,0x00,0x00}, // 0
  {0x00,0x00,0x42,0x7F,0x40,0x00,0x00,0x00}, // 1
  {0x00,0x62,0x51,0x49,0x49,0x46,0x00,0x00}, // 2
  {0x00,0x22,0x41,0x49,0x49,0x36,0x00,0x00}, // 3
  {0x00,0x18,0x14,0x12,0x7F,0x10,0x00,0x00}, // 4
  {0x00,0x27,0x45,0x45,0x45,0x39,0x00,0x00}, // 5
  {0x00,0x3C,0x4A,0x49,0x49,0x30,0x00,0x00}, // 6
  {0x00,0x01,0x71,0x09,0x05,0x03,0x00,0x00}, // 7
  {0x00,0x36,0x49,0x49,0x49,0x36,0x00,0x00}, // 8
  {0x00,0x06,0x49,0x49,0x29,0x1E,0x00,0x00}, // 9
  {0x00,0x00,0x36,0x36,0x00,0x00,0x00,0x00}, // :
  {0x00,0x00,0xAC,0x6C,0x00,0x00,0x00,0x00}, // ;
  {0x00,0x08,0x14,0x22,0x41,0x00,0x00,0x00}, // <
  {0x00,0x14,0x14,0x14,0x14,0x14,0x00,0x00}, // =
  {0x00,0x41,0x22,0x14,0x08,0x00,0x00,0x00}, // >
  {0x00,0x02,0x01,0x51,0x09,0x06,0x00,0x00}, // ?
  {0x00,0x32,0x49,0x79,0x41,0x3E,0x00,0x00}, // @
  {0x00,0x7E,0x09,0x09,0x09,0x7E,0x00,0x00}, // A
  {0x00,0x7F,0x49,0x49,0x49,0x36,0x00,0x00}, // B
  {0x00,0x3E,0x41,0x41,0x41,0x22,0x00,0x00}, // C
  {0x00,0x7F,0x41,0x41,0x22,0x1C,0x00,0x00}, // D
  {0x00,0x7F,0x49,0x49,0x49,0x41,0x00,0x00}, // E
  {0x00,0x7F,0x09,0x09,0x09,0x01,0x00,0x00}, // F
  {0x00,0x3E,0x41,0x41,0x51,0x72,0x00,0x00}, // G
  {0x00,0x7F,0x08,0x08,0x08,0x7F,0x00,0x00}, // H
  {0x00,0x41,0x7F,0x41,0x00,0x00,0x00,0x00}, // I
  {0x00,0x20,0x40,0x41,0x3F,0x01,0x00,0x00}, // J
  {0x00,0x7F,0x08,0x14,0x22,0x41,0x00,0x00}, // K
  {0x00,0x7F,0x40,0x40,0x40,0x40,0x00,0x00}, // L
  {0x00,0x7F,0x02,0x0C,0x02,0x7F,0x00,0x00}, // M
  {0x00,0x7F,0x04,0x08,0x10,0x7F,0x00,0x00}, // N
  {0x00,0x3E,0x41,0x41,0x41,0x3E,0x00,0x00}, // O
  {0x00,0x7F,0x09,0x09,0x09,0x06,0x00,0x00}, // P
  {0x00,0x3E,0x41,0x51,0x21,0x5E,0x00,0x00}, // Q
  {0x00,0x7F,0x09,0x19,0x29,0x46,0x00,0x00}, // R
  {0x00,0x26,0x49,0x49,0x49,0x32,0x00,0x00}, // S
  {0x00,0x01,0x01,0x7F,0x01,0x01,0x00,0x00}, // T
  {0x00,0x3F,0x40,0x40,0x40,0x3F,0x00,0x00}, // U
  {0x00,0x1F,0x20,0x40,0x20,0x1F,0x00,0x00}, // V
  {0x00,0x3F,0x40,0x38,0x40,0x3F,0x00,0x00}, // W
  {0x00,0x63,0x14,0x08,0x14,0x63,0x00,0x00}, // X
  {0x00,0x03,0x04,0x78,0x04,0x03,0x00,0x00}, // Y
  {0x00,0x61,0x51,0x49,0x45,0x43,0x00,0x00}, // Z
  {0x00,0x7F,0x41,0x41,0x00,0x00,0x00,0x00}, // [
  {0x00,0x02,0x04,0x08,0x10,0x20,0x00,0x00}, // \/
  {0x00,0x41,0x41,0x7F,0x00,0x00,0x00,0x00}, // ]
  {0x00,0x04,0x02,0x01,0x02,0x04,0x00,0x00}, // ^
  {0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00}, // _
  {0x00,0x01,0x02,0x04,0x00,0x00,0x00,0x00}, // `
  {0x00,0x20,0x54,0x54,0x54,0x78,0x00,0x00}, // a
  {0x00,0x7F,0x48,0x44,0x44,0x38,0x00,0x00}, // b
  {0x00,0x38,0x44,0x44,0x28,0x00,0x00,0x00}, // c
  {0x00,0x38,0x44,0x44,0x48,0x7F,0x00,0x00}, // d
  {0x00,0x38,0x54,0x54,0x54,0x18,0x00,0x00}, // e
  {0x00,0x08,0x7E,0x09,0x02,0x00,0x00,0x00}, // f
  {0x00,0x18,0xA4,0xA4,0xA4,0x7C,0x00,0x00}, // g
  {0x00,0x7F,0x08,0x04,0x04,0x78,0x00,0x00}, // h
  {0x00,0x00,0x7D,0x00,0x00,0x00,0x00,0x00}, // i
  {0x00,0x80,0x84,0x7D,0x00,0x00,0x00,0x00}, // j
  {0x00,0x7F,0x10,0x28,0x44,0x00,0x00,0x00}, // k
  {0x00,0x41,0x7F,0x40,0x00,0x00,0x00,0x00}, // l
  {0x00,0x7C,0x04,0x18,0x04,0x78,0x00,0x00}, // m
  {0x00,0x7C,0x08,0x04,0x7C,0x00,0x00,0x00}, // n
  {0x00,0x38,0x44,0x44,0x38,0x00,0x00,0x00}, // o
  {0x00,0xFC,0x24,0x24,0x18,0x00,0x00,0x00}, // p
  {0x00,0x18,0x24,0x24,0xFC,0x00,0x00,0x00}, // q
  {0x00,0x00,0x7C,0x08,0x04,0x00,0x00,0x00}, // r
  {0x00,0x48,0x54,0x54,0x24,0x00,0x00,0x00}, // s
  {0x00,0x04,0x7F,0x44,0x00,0x00,0x00,0x00}, // t
  {0x00,0x3C,0x40,0x40,0x7C,0x00,0x00,0x00}, // u
  {0x00,0x1C,0x20,0x40,0x20,0x1C,0x00,0x00}, // v
  {0x00,0x3C,0x40,0x30,0x40,0x3C,0x00,0x00}, // w
  {0x00,0x44,0x28,0x10,0x28,0x44,0x00,0x00}, // x
  {0x00,0x1C,0xA0,0xA0,0x7C,0x00,0x00,0x00}, // y
  {0x00,0x44,0x64,0x54,0x4C,0x44,0x00,0x00}, // z
  {0x00,0x08,0x36,0x41,0x00,0x00,0x00,0x00}, // {
  {0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00}, // |
  {0x00,0x41,0x36,0x08,0x00,0x00,0x00,0x00}, // }
  {0x00,0x02,0x01,0x01,0x02,0x01,0x00,0x00}, // ~
  {0x00,0x02,0x05,0x05,0x02,0x00,0x00,0x00} 
};

Oled12864::Oled12864() :
    m_state(STATE_START) {
    // nothing left to write here
} // constructor

void Oled12864::setup() {
    Wire.begin();
    wait(0);
} // setup

void Oled12864::run(byte _serv) {
    switch (m_state) {
        case STATE_START:
            sendCommand(OLED12864_DISPLAY_OFF);
            m_state = STATE_OFF;
            wait(5); 
            break;
        case STATE_OFF:
            sendCommand(OLED12864_DISPLAY_ON);
            m_state = STATE_ON;
            wait(5); 
            break;
        case STATE_ON:
            sendCommand(OLED12864_NORMAL_DISPLAY);
            event(EVENT_READY);
            break;
    }
} // run

void Oled12864::setNormalDisplay() {
    sendCommand(OLED12864_NORMAL_DISPLAY);
} // setNormalDisplay

void Oled12864::setInverseDisplay() {
    sendCommand(OLED12864_INVERSE_DISPLAY);
} // setInverseDisplay

void Oled12864::setPageMode() {
    m_addressingMode = OLED12864_PAGE_MODE;
    sendCommand(OLED12864_ADDRESSING_MODE);
    sendCommand(m_addressingMode);
} // setPageMode

void Oled12864::setHorizontalMode() {
    m_addressingMode = OLED12864_HORIZONTAL_MODE;
    sendCommand(OLED12864_ADDRESSING_MODE);
    sendCommand(m_addressingMode);
} // setHorizontalMode


void Oled12864::setTextXY(byte _row, byte _column) {
    sendCommand(0xB0 + _row);                           //set page address
    sendCommand(0x00 + (8 * _column & 0x0F));           //set column lower address
    sendCommand(0x10 + ((8 * _column >> 4) & 0x0F));    //set column higher address
} // setTextXY


void Oled12864::clearDisplay() {
    sendCommand(OLED12864_DISPLAY_OFF);   //display off
    for(byte j = 0; j < 8; j++) { 
        setTextXY(j, 0);    
        for(byte i = 0; i < 16; i++) putChar(' '); //clear all columns
    }
    sendCommand(OLED12864_DISPLAY_ON);    //display on
    setTextXY(0, 0);    
} // clearDisplay

void Oled12864::setBrightness(byte _brightness) {
   sendCommand(OLED12864_SET_BRIGHTNESS);
   sendCommand(_brightness);
} // setBrightness 


void Oled12864::putChar(byte _c) {
    if(_c < 32 || _c > 127) _c=' '; //Ignore non-printable ASCII characters. This can be modified for multilingual font.
    for(byte i = 0; i < 8; i++) sendData(pgm_read_byte(&BasicFont[_c-32][i])); //font array starts at 0, ASCII starts at 32. Hence the translation
} // putChar

void Oled12864::putString(const byte _string[]) {
    byte i = 0;
    while(_string[i]) putChar(_string[i++]);
} // putString


byte Oled12864::putNumber(long _number) {
    byte char_buffer[10]="";
    byte i = 0;
    byte f = 0;

    if (_number < 0) {
        f = 1;
        putChar('-');
        _number = -_number;
    } else if (_number == 0) {
        f = 1;
        putChar('0');
        return f;
    } 

    while (_number > 0) {
      char_buffer[i++] = _number % 10;
      _number /= 10;
    }
    f += i;
    for(; i > 0; i--) {
      putChar('0'+ char_buffer[i - 1]);
    }
    return f;
} // putNumber


byte Oled12864::putFloat(float _number, byte _decimal) {
    unsigned int temp = 0;
    float decy = 0.0;
    float rounding = 0.5;
    byte f = 0;
    if(_number < 0.0) {
        putString("-");
        _number = -_number;
        f += 1;
    }
    for (byte i = 0; i < _decimal; ++i) rounding /= 10.0;
    _number += rounding;
    
    temp = _number;
    f += putNumber(temp);
    if(_decimal > 0) {
      putChar('.');
      f += 1;
    }
    decy = _number - temp;//decimal part, 
    for(byte i = 0;i < _decimal; i++) { //4 
      decy *= 10; // for the next decimal
      temp = decy;//get the decimal
      putNumber(temp);
      decy -= temp;
    }
    f += _decimal;
    return f;
} // putFloat

byte Oled12864::putFloat(float _number) {
    return putFloat(_number, 2);
} // putFloat

void Oled12864::drawBitmap(byte *_bitmap,int _bytes) {
  byte localAddressMode = m_addressingMode;
  if (m_addressingMode != OLED12864_HORIZONTAL_MODE) setHorizontalMode();   // bitmap is drawn in horizontal mode
  for(int i = 0; i < _bytes; i++) sendData(pgm_read_byte(&_bitmap[i]));
  if (localAddressMode == OLED12864_PAGE_MODE) setPageMode();               // if pageMode was used earlier, restore it.
} // drawBitmap

void Oled12864::setScrollProperties(bool _direction, byte _startPage, byte _endPage, byte _scrollSpeed) {
    /*
    Use the following defines for 'direction' :

     Scroll_Left            
     Scroll_Right           

    Use the following defines for 'scrollSpeed' :

     Scroll_2Frames     
     Scroll_3Frames
     Scroll_4Frames
     Scroll_5Frames 
     Scroll_25Frames
     Scroll_64Frames
     Scroll_128Frames
     Scroll_256Frames

    */
    if(Scroll_Right == _direction) 
        sendCommand(OLED12864_RIGHT_SCROLL);
    else 
        sendCommand(OLED12864_LEFT_SCROLL);

    sendCommand(0x00);
    sendCommand(_startPage);
    sendCommand(_scrollSpeed);
    sendCommand(_endPage);
    sendCommand(0x00);
    sendCommand(0xFF);
} // setScrollProperties

void Oled12864::activateScroll() {
    sendCommand(OLED12864_ACTIVATE_SCROLL);
} // activateScroll

void Oled12864::deactivateScroll() {
    sendCommand(OLED12864_DEACTIVATE_SCROLL);
} // deactivateScroll

void Oled12864::sendCommand(byte _command) {
  Wire.beginTransmission(OLED12864_ADDRESS);
  Wire.write(OLED12864_COMMAND_MODE);
  Wire.write(_command);
  Wire.endTransmission();
} // sendCommand

void Oled12864::sendData(byte _data) {
     Wire.beginTransmission(OLED12864_ADDRESS);
     Wire.write(OLED12864_DATA_MODE);
     Wire.write(_data);
     Wire.endTransmission();
} // sendData